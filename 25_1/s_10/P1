using System;
using System.Collections.Generic;

namespace Sorting
{
    class Program
    {
        static void Main(string[] args)
        {
            // Test arrays
            int[] smallArray = { 5, 2, 8, 1, 9 };
            int[] mediumArray = { 64, 34, 25, 12, 22, 11, 90 };
            int[] largeArray = GenerateRandomArray(1000);
            
            Console.WriteLine("\n\tBad Sort");
            TestSortingAlgorithm("Bad Sort", BadSort, smallArray.Clone() as int[]);
            
            Console.WriteLine("\n\tQuick Sort");
            TestSortingAlgorithm("Quick Sort", QuickSort, smallArray.Clone() as int[]);
            
            Console.WriteLine("\n\tMerge Sort");
            TestSortingAlgorithm("Merge Sort", MergeSort, smallArray.Clone() as int[]);
            
            Console.WriteLine("\n\tHeap Sort");
            TestSortingAlgorithm("Heap Sort", HeapSort, smallArray.Clone() as int[]);
        }
        
        static void TestSortingAlgorithm(string name, Action<int[]> sortFunction, int[] array)
        {
            Console.WriteLine($"Given array: [{string.Join(", ", array)}]");
            sortFunction(array);
            Console.WriteLine($"After {name}: [{string.Join(", ", array)}]");
        }
        
        static bool IsSorted(int[] arr)
        {
            for (int i=0; i<arr.Length-1; i++) if (arr[i]>arr[i+1]) return false;
            return true;
        }
        
        static int[] GenerateRandomArray(int size)
        {
            Random rd = new Random();
            int[] arr = new int[size];
            for (int i=0; i<size; i++)
            {
                arr[i] = rd.Next(1, 1000);
            }
            return arr;
        }
        
        // 1. Bad Sort O(n^2)
        static void BadSort(int[] arr)
        {
            for (int i=0; i<arr.Length; i++)
            {
                for (int j=0; j<arr.Length; j++)
                {
                    if (arr[i]<arr[j])
                    {
                        int temp = arr[i];
                        arr[i] = arr[j];
                        arr[j] = temp;
                    }
                }
            }
        }
        
        // 3. Quick Sort with random pivot
        static void QuickSort(int[] arr)
        {
            QuickSort(arr, 0, arr.Length-1);
        }
        
        static void QuickSort(int[] arr, int low, int high)
        {
            if (low<high)
            {
                int pivotIndex = PartitionRandom(arr, low, high);
                QuickSort(arr, low, pivotIndex-1);
                QuickSort(arr, pivotIndex+1, high);
            }
        }
        
        static int PartitionRandom(int[] arr, int low, int high)
        {
            Random rand = new Random();
            int randomIndex = rand.Next(low, high+1);
            // Swap random element with last element
            int c = arr[randomIndex];
            arr[randomIndex] = arr[high];
            arr[high] = c;
            
            return Partition(arr, low, high);
        }
        
        static int Partition(int[] arr, int low, int high)
        {
            int pivot = arr[high];
            int i = low-1;
            
            for (int j=low; j<high; j++)
            {
                if (arr[j]<=pivot)
                {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            
            int temp2 = arr[i+1];
            arr[i+1] = arr[high];
            arr[high] = temp2;
            
            return i + 1;
        }
        
        // Quick Sort with average pivot 
        static void QuickSortAveragePivot(int[] arr)
        {
            QuickSortAverage(arr, 0, arr.Length-1);
        }
        
        static void QuickSortAverage(int[] arr, int low, int high)
        {
            if (low<high)
            {
                int pivotIndex = PartitionAverage(arr, low, high);
                QuickSortAverage(arr, low, pivotIndex-1);
                QuickSortAverage(arr, pivotIndex+1, high);
            }
        }
        
        static int PartitionAverage(int[] arr, int low, int high)
        {
            int mid = low+(high-low)/2;
            
            if (arr[low] > arr[mid]) Swap(arr, low, mid);
            if (arr[low] > arr[high]) Swap(arr, low, high);
            if (arr[mid] > arr[high]) Swap(arr, mid, high);
            
            // Place pivot at high-1
            Swap(arr, mid, high-1);
            return Partition(arr, low+1, high-1);
        }
        
        static void Swap(int[] arr, int i, int j)
        {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        
        // 4. Merge Sort
        static void MergeSort(int[] arr)
        {
            if (arr.Length<=1) return;
            
            int[] temp = new int[arr.Length];
            MergeSort(arr, temp, 0, arr.Length-1);
        }
        
        static void MergeSort(int[] arr, int[] temp, int left, int right)
        {
            if (left<right)
            {
                int mid = left+(right-left)/2;
                
                MergeSort(arr, temp, left, mid);
                MergeSort(arr, temp, mid+1, right);
                Merge(arr, temp, left, mid, right);
            }
        }
        
        static void Merge(int[] arr, int[] temp, int left, int mid, int right)
        {
            int i = left;
            int j = mid+1;
            int k = left;
            
            while (i<=mid && j<=right)
            {
                if (arr[i]<=arr[j]) temp[k++] = arr[i++];
                else temp[k++] = arr[j++];
            }
            
            while (i<=mid) temp[k++] = arr[i++];
            
            while (j<=right) temp[k++] = arr[j++];
            
            for (int l=left; l<=right; l++) arr[l] = temp[l];
        }
        
        // 5. Heap Sort
        static void HeapSort(int[] arr)
        {
            int n = arr.Length;
            
            // Build max heap
            for (int i=n/2-1; i>=0; i--) Heapify(arr, n, i);
            
            // Extract elements from heap
            for (int i=n-1; i>0; i--)
            {
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
                
                Heapify(arr, i, 0);
            }
        }
        
        static void Heapify(int[] arr, int n, int i)
        {
            int largest = i;
            int left = 2*i+1;
            int right = 2*i+2;
            
            if (left<n && arr[left]>arr[largest]) largest = left;
            
            if (right<n && arr[right]>arr[largest]) largest = right;
            
            if (largest!=i)
            {
                int temp = arr[i];
                arr[i] = arr[largest];
                arr[largest] = temp;
                
                Heapify(arr, n, largest);
            }
        }
    }
}
